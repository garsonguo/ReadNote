## 编译原理
执行前编译

## 理解作用域
引擎：负责整个JS的编译和执行过程；</br>

编译器：负责语法分析及代码生成等；</br>

作用域：负责收集并维护所有声明的标识符组成的一系列查询，在一套严格的标准里，确定当前代码的访问权限；</br>

变量的赋值会执行两个动作：首先编译器会在当前作用域声明一个变量（若之前没有声明过），其次运行时会在当前作用域查找该变量，若能找到就对他赋值。</br>

LHS和RHS解读：</br>
LHS:复制操作的目标是谁；复制操作</br>
RHS:谁是赋值操作的源头；取到它的源值</br>

作用域：根据名称查找变量的一套规则。</br>
作用域嵌套：一个块或函数嵌套在另一个块或函数中。查找变量时从当前作用域开始向上查找一直到全局作用域，找到为止。</br>


ES5中引入了“严格模式”，严格模式中禁止隐式或自动的创建全局变量。宽松模式中，所有作用域中，若找不到所查找的变量，全局作用域中就会创建一个具有该名称的变量。

referenceError同作用域判别失败相关（找不到该变量等），TypeError作用域判别成功，结果非法或不合理。

## 小结
作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声
明会被分解成两个独立的步骤：

首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。

LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所
需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层
楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。

不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式
地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛
出 ReferenceError 异常（严格模式下）。



