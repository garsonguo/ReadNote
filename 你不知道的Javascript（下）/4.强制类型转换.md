## 值类型转换
将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion）。JavaScript 中的强制类型转换总是返回标量基本类型值（参见第 2 章），如字符串、数字和布尔值，不会返回对象和函数。

类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）。然而在 JavaScript 中通常将它们统称为强制类型转换，作者则倾向于用“隐式强制类型转换”（implicit coercion）和“显式强制类型转换”（explicit coercion）来区分。如：

    var a = 42;
    var b = a + ""; // 隐式强制类型转换
    var c = String( a ); // 显式强制类型转换

两者都是将数字 42 转换为字符串 "42"。

## 抽象值操作
字符串、数字和布尔值之间类型转换的基本规则ToString、ToNumber 和 ToBoolean，ToPrimitive。

ToString：负责处理非字符串到字符串的强制类型转换，基本类型值的字符串化规则为：null 转换为 "null"，undefined 转换为 "undefined"，true转换为 "true"。对普通对象来说，除非自行定义，否则 toString()（Object.prototype.toString()）返回内部属性 [[Class]] 的值（参见第 3 章），如 "[object Object]"。数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 "," 连接起来：

    var a = [1,2,3];
    a.toString(); // "1,2,3"

JSON 字符串化：JSON.stringify(..) 在将 JSON 对象序列化为字符串时也用到了 ToString，对大多数简单值来说，JSON 字符串化和 toString() 的效果基本相同，只不过序列化的结果总是字符串：

    JSON.stringify( 42 ); // "42"
    JSON.stringify( "42" ); // ""42"" （含有双引号的字符串）
    JSON.stringify( null ); // "null"
    JSON.stringify( true ); // "true"

所有安全的 JSON 值（JSON-safe）都可以使用 JSON.stringify(..) 字符串化。安全的JSON 值是指能够呈现为有效 JSON 格式的值。
什么是不安全的 JSON 值：undefined、function、symbol（ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合 JSON结构标准，支持 JSON 的语言无法处理它们。JSON.stringify(..) 在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null。

如果对象中定义了 toJSON() 方法，JSON 字符串化时会首先调用该方法，然后用它的返回值来进行序列化。如果要对含有非法 JSON 值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义 toJSON() 方法来返回一个安全的 JSON 值。toJSON() 返回的应该是一个适当的值，可以是任何类型，然后再由 JSON.stringify(..) 对其进行字符串化。
***
ToNumber：其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

ToBoolean：JavaScript 中布尔值和数字是不一样的，所以不要将数值 1 和 0 分别等同于 true 和 false。以下这些是假值：undefined、null、false、+0、-0 和 NaN、""。假值列表以外的值都是真值。

## 显示强制类型转换
字符串和数字之间的显式转换：字符串和数字之间的转换是通过 String(..) 和 Number(..) 这两个内建函数（原生构造函数，参见第 3 章）来实现的，请注意它们前面没有 new 关键字，并不创建封装对象。如下：

    var a = 42;
    var b = String( a );
    var c = "3.14";
    var d = Number( c );
    b; // "42"
    d; // 3.14
***
日期显式转换为数字：一元运算符 + 的另一个常见用途是将日期（Date）对象强制类型转换为数字，返回结果为Unix 时间戳，以微秒为单位：

    var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );
    +d; // 1408369986000
    常用写法：var timestamp = +new Date();

不建议对日期类型使用强制类型转换，应该使用 Date.now() 来获得当前的时间戳，使用 new Date(..).getTime() 来获得指定时间的时间戳。
***
显式解析数字字符串：解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者之间还是有明显的差别。如下：

    var a = "42";
    var b = "42px";
    Number( a ); // 42
    parseInt( a ); // 42
    Number( b ); // NaN
    parseInt( b ); // 42

解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回 NaN。parseInt(..) 针对的是字符串值。向 parseInt(..) 传递数字和其他类型的参数是没有用的，比如 true、function(){...} 和 [1,2,3]。
***
显式转换为布尔值：不常用。
***
## 隐式强制类型转换
隐式强制类型转换的作用是减少冗余，让代码更简洁。

字符串和数字之间的隐式强制类型转换：+ 运算符即能用于数字加法，也能用于字符串拼接。

隐式强制类型转换为布尔值：下面的情况会发生布尔值隐式强制类型转换：

    (1) if (..) 语句中的条件判断表达式。
    (2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。
    (3) while (..) 和 do..while(..) 循环中的条件判断表达式。
    (4) ? : 中的条件判断表达式。
    (5) 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）。

&& 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。

## 宽松相等和严格相等
宽松相等（loose equals）== 和严格相等（strict equals）=== 都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。“== 允许在相等比较中进行强制类型转换，而 === 不允许。”，误区：“== 检查值是否相等，=== 检查值和类型是否相等”。

## 小结
本章介绍了 JavaScript 的数据类型之间的转换，即强制类型转换：包括显式和隐式。强制类型转换常常为人诟病，但实际上很多时候它们是非常有用的。作为有使命感的JavaScript 开发人员，我们有必要深入了解强制类型转换，这样就能取其精华，去其糟粕。

显式强制类型转换明确告诉我们哪里发生了类型转换，有助于提高代码可读性和可维护性。

隐式强制类型转换则没有那么明显，是其他操作的副作用。感觉上好像是显式强制类型转换的反面，实际上隐式强制类型转换也有助于提高代码的可读性。

在处理强制类型转换的时候要十分小心，尤其是隐式强制类型转换。在编码的时候，要知其然，还要知其所以然，并努力让代码清晰易读。